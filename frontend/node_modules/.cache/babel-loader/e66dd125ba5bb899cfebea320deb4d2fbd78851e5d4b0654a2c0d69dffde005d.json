{"ast":null,"code":"var _jsxFileName = \"/Users/chrissanga/Desktop/projects/react-routing-practice/frontend/src/pages/EventDetail.js\",\n  _s = $RefreshSig$();\nimport { redirect, useRouteLoaderData, Await } from \"react-router-dom\";\nimport EventItem from \"../components/EventItem\";\nimport EventsList from \"../components/EventsList\";\nimport { Suspense } from \"react\";\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nexport default function EventDetailPage() {\n  _s();\n  // works almost like useLoaderData, but takes a route id as an argument that specifies which loader should be used\n  const {\n    event,\n    events\n  } = useRouteLoaderData('event-detail');\n  return /*#__PURE__*/_jsxDEV(_Fragment, {\n    children: [/*#__PURE__*/_jsxDEV(Suspense, {\n      children: /*#__PURE__*/_jsxDEV(Await, {\n        resolve: event,\n        children: loadedEvent => /*#__PURE__*/_jsxDEV(EventItem, {\n          event: loadedEvent\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 14,\n          columnNumber: 27\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 13,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 12,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(Await, {\n      resolve: events,\n      children: loadedEvents => /*#__PURE__*/_jsxDEV(EventsList, {\n        events: loadedEvents\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 18,\n        columnNumber: 26\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 17,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true);\n}\n_s(EventDetailPage, \"OA7jEBfO3UI1aCR8ByPCigEHUtE=\", false, function () {\n  return [useRouteLoaderData];\n});\n_c = EventDetailPage;\nasync function loadEvent(id) {\n  const response = await fetch('http://localhost:8080/events/' + id);\n  if (!response.ok) {\n    throw new Response(JSON.stringify({\n      message: 'Could not fetch details for selected event.'\n    }), {\n      status: 500\n    });\n  } else {\n    // this has to be manually parsed instead of returning a response because of the deferred step in between the loader and useLoaderData\n    const resData = await response.json();\n    return resData.event;\n  }\n}\n\n// Moving this function out of the loader allows us to defer loading the events so the page loads without them then populates the events when the data is sent from the backend\nasync function loadEvents() {\n  const response = await fetch('http://localhost:8080/events');\n  if (!response.ok) {\n    //return { isError: true, message: 'Could not fetch events.' };\n    throw new Response(JSON.stringify({\n      message: 'Could not fetch events.'\n    }), {\n      status: 500\n    });\n  } else {\n    // this has to be manually parsed instead of returning a response because of the deferred step in between the loader and useLoaderData\n    const resData = await response.json();\n    return resData.events;\n  }\n}\n\n// react router, which calls the loader function passes an object to the loader function when it's executed. The object contains a request property, which contains a request object, and a params property, which contains an object with all the route parameters. The request object can be used to access the URL to access things like query parameters. The params object allows us to access the eventId route parameter\nexport async function loader({\n  request,\n  params\n}) {\n  const id = params.eventId;\n  return {\n    event: loadEvent(id),\n    events: loadEvents()\n  };\n}\nexport async function action({\n  params,\n  request\n}) {\n  const eventId = params.eventId;\n  const response = await fetch('http://localhost:8080/events/' + eventId, {\n    method: request.method\n  });\n  if (!response.ok) {\n    throw new Response(JSON.stringify({\n      message: 'Could not delete event.'\n    }), {\n      status: 500\n    });\n  }\n  return redirect('/events');\n}\nvar _c;\n$RefreshReg$(_c, \"EventDetailPage\");","map":{"version":3,"names":["redirect","useRouteLoaderData","Await","EventItem","EventsList","Suspense","jsxDEV","_jsxDEV","Fragment","_Fragment","EventDetailPage","_s","event","events","children","resolve","loadedEvent","fileName","_jsxFileName","lineNumber","columnNumber","loadedEvents","_c","loadEvent","id","response","fetch","ok","Response","JSON","stringify","message","status","resData","json","loadEvents","loader","request","params","eventId","action","method","$RefreshReg$"],"sources":["/Users/chrissanga/Desktop/projects/react-routing-practice/frontend/src/pages/EventDetail.js"],"sourcesContent":["import { redirect, useRouteLoaderData, Await } from \"react-router-dom\";\nimport EventItem from \"../components/EventItem\";\nimport EventsList from \"../components/EventsList\";\nimport { Suspense } from \"react\";\n\nexport default function EventDetailPage() {\n  // works almost like useLoaderData, but takes a route id as an argument that specifies which loader should be used\n  const {event, events} = useRouteLoaderData('event-detail');\n\n  return (\n    <>\n      <Suspense>\n        <Await resolve={event}>\n          {loadedEvent => <EventItem event={loadedEvent} />}\n        </Await>\n      </Suspense>\n      <Await resolve={events}>\n        {loadedEvents => <EventsList events={loadedEvents} />}\n      </Await>\n    </>\n  );\n}\n\nasync function loadEvent(id) {\n  const response = await fetch('http://localhost:8080/events/' + id);\n  \n  if (!response.ok) {\n    throw new Response(JSON.stringify({message: 'Could not fetch details for selected event.'}), {status: 500,});\n  }\n  else {\n      // this has to be manually parsed instead of returning a response because of the deferred step in between the loader and useLoaderData\n      const resData = await response.json();\n      return resData.event;\n  }\n}\n\n// Moving this function out of the loader allows us to defer loading the events so the page loads without them then populates the events when the data is sent from the backend\nasync function loadEvents() {\n  const response = await fetch('http://localhost:8080/events');\n\n  if (!response.ok) {\n    //return { isError: true, message: 'Could not fetch events.' };\n    throw new Response(JSON.stringify({message: 'Could not fetch events.'}), {status: 500,});\n  } else {\n    // this has to be manually parsed instead of returning a response because of the deferred step in between the loader and useLoaderData\n    const resData = await response.json();\n    return resData.events;\n  }\n}\n\n// react router, which calls the loader function passes an object to the loader function when it's executed. The object contains a request property, which contains a request object, and a params property, which contains an object with all the route parameters. The request object can be used to access the URL to access things like query parameters. The params object allows us to access the eventId route parameter\nexport async function loader({request, params}) {\n  const id = params.eventId;\n  \n  return {\n    event: loadEvent(id),\n    events: loadEvents(),\n  };\n}\n\nexport async function action({ params, request }) {\n  const eventId = params.eventId;\n  const response = await fetch('http://localhost:8080/events/' + eventId, {\n    method: request.method,\n  });\n\n  if (!response.ok) {\n    throw new Response(JSON.stringify({message: 'Could not delete event.'}), {status: 500,});\n  }\n\n  return redirect('/events');\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}